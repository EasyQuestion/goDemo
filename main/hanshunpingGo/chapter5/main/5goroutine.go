package main

import (
	"fmt"
	"runtime"
)

func main() {
	// go来设置cpu数目
	cpuNum := runtime.NumCPU()
	fmt.Println("cpu num:", cpuNum)
	runtime.GOMAXPROCS(cpuNum - 1)
	fmt.Println("ok")
}

//----------------------------------------------------------
/*func main() {
	// go主线程每隔1秒输出一句“hello,go”,执行10次退出;goroutine每隔1秒输出一句“hello,world”

	// 基本语法 go 关键字来开启协程
	go func() {
		i := 0
		for {
			fmt.Println("go: hello,world", i)
			i++
			time.Sleep(time.Second)
		}
	}()

	for i := 0; i < 10; i++ {
		fmt.Println("main: hello,golang",i)
		time.Sleep(time.Second)
	}
}*/

// goroutine 协程
// channel 管道

// 基本概念：进程、线程
// 进程：程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位
// 线程：线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位
// 一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行
// 一个程序至少有一个进程，一个进程至少有一个线程

// 并发、并行
// 并发：同时出发，一般单核CPU的会这样搞（从微观角度上讲，在某一个时间点只执行一个任务）
// 并行，并行行驶，一般多核CPU才能做到（从微观角度上讲，这才是真正的同时执行）

// go 协程、go主线程
// go主线程：可以理解成线程，也可以理解为进程，一个go线程上可以起多个协程
// go协程：轻量级的线程（编译器做优化）
// 协程特点：有独立的栈空间，共享程序堆空间，调度由用户控制，

// 基本语法 go 关键字来开启协程
// 如果go主线程退出了，协程即使没有执行完，也会退出
// 如果协程执行完成，主线程没有执行完，协程也会退出

// go主线程是物理线程，直接作用在cpu上的，是重量级的，非常消耗cpu资源
// go协程是从主线程开启的，是轻量级的线程，是逻辑态，对资源消耗相对小。
// golang的协程机制是重要的特点，可以轻松开启上万个协程。（其它语言的并发机制一般是基于线程的，开启过多会耗费大量资源）
// 线程是内核态的，比较重量级，几千个线程可能耗光CPU

// goroutine调度模型:MPG模式
// M 操作系统主线程（物理线程）
// P 协程执行需要的上下文
// G 协程
// 可以有多个M，可以是同一个CPU,也可以是不同的CPU
// 当M被一个G阻塞时，P会自动再创建一个M来执行其它的G，防止其它的G被阻塞，P可以来回切换多个M

// 设置运行的cpu数目 runtime包下2个核心方法 NumCPU() GOMAXPROCS()
// go 1.8之后,默认使用多核，不用再单独设置，但是go 1.8之前，还是要设置下，提高cpu的利用率